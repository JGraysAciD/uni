\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{amssymb,amsmath}
<<<<<<< HEAD
\usepackage{textcomp} 
=======
\usepackage{hyperref}
\usepackage{textcomp}
>>>>>>> 57f5d65c7a549c8aca978ac760976c3df3a682c3
\author{Claas Jaehrling, Sven-Hendrik Haase}
\title{RS1 HA zum 25.11.11}
\date{\today}
\begin{document}
\setcounter{secnumdepth}{0}
\maketitle

\section{Aufgabe 4.1}
Das Problem hierbei ist, dass dieser Vergleich nur bei Zahlen, die Nahe bei
einander liegen, funktioniert.
\\
Es handelt sich um ein komplexes Problem, dass in großer Breite hier
(\url{http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm}) und hier (\url{http://stackoverflow.com/questions/3667932/why-use-float-floattointbits-in-java-float-comparisons}) diskutiert wird.
\\
Der Konsenz scheint zu sein, dass ein Epsilon eine unzuverlässige Wahl ist, während Epsilon in Kombination mit relativem Fehlerwert ein besserer Weg ist:
\begin{verbatim}
return Math.abs(a - b) < EPSILON * Math.max(Math.abs(a), Math.abs(b))
\end{verbatim}

\section{Aufgabe 4.2}
\subsection{(a)}
ISO-8859-1 verwendet 8-bit Koderierung, also: \[500000 * 8bit = 500000byte\]
Direkte Unicode-Kodierung basiert auf 16-bit, also: \[500000 * 16bit = 1000000byte\]
Für UTF-8 benötigen wir die Anzahl der Sonderzeichen, da diese mit 16-bit Kodiert werden, die regulären Zeichen aber über 8-bit.
\\
Anzahl der Sonderzeichen:
\[0.0056 * 500000 + 0.00287 * 500000 + 0.00616 * 500000 + 0.00308 * 500000 = 8855 \]
Anzahl der regulären Zeichen:
\[500000 - 8855 = 491145\]
Also ergibt sich:
\[491145 * 8bit + 8855 * 16bit = 508855byte\]

\subsection{(b)}
Anzahl der Symbole:
\[0x4BDF-0x3400+0x9FCF-0x4E00 = 27054\]

\subsection{(c)}
Wir haben bei direkter Unicode-Kodierung wieder:
\[500000 * 16bit = 1000000byte\]

Für diesen Bereich von UTF-8 werden 24bit pro Zeichen benötigt:
\[500000 * 24bit = 1500000byte\]

\section{Aufgabe 4.3}
\subsection{(a)}
\begin{align}
&y = 18 * x\\
&= (2^4) * x + (2^1) * x\\
&= (x << 4) + (x << 1)
\end{align}
\subsection{(b)}
\begin{align}
&y = 14 * x\\
&= (2^4) * x - (2^1) * x\\
&= (x << 4) - (x << 1)
\end{align}
\subsection{(c)}
\begin{align}
&y = -56 * x\\
&= (2^3) * x - (2^6) * x\\
&= (x << 3) - (x << 6)
\end{align}
\subsection{(d)}
\begin{align}
&y = 62 * (x + 2)\\
&= 62 * x + 124\\
&= (2^6) * x - (2^1) * x + 124\\
&= (x << 6) - (x << 1) + 124
\end{align}

\section{Aufgabe 4.4}
\subsection{(a)}
\begin{align}
public int bitNand(int x,int y)\\
&// das, was nicht die Schnittmenge von x und y ist\\
&// (x\& y)  = ~ (x | y)\\
&// = (~ x | ~ y)\\
&return  ~ x | ~ y
\end{align}

\subsection{(b)}
\begin{align}
&public int bitXnor(int x,int y)\\
&// das, was nicht die Schnittmenge von x und y ist\\
&// (x\& y)  = ~ (x | y)\\
&= (~ x | ~ y)\\
&return x | y
\end{align}

\subsection{(c)}
\begin{align}
&public int getByte(x,n)\\
&return
\end{align}
\subsection{(d)}
\begin{align}
&public int rotateLeft(x,n)
\end{align}
\subsection{(e)}
\begin{align}
&public int abs(x)
\end{align}


\section{Aufgabe 4.5}
\subsection{(a)}
\begin{align}
\end{align}
\end{document}
